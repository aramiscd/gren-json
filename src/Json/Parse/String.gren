module Json.Parse.String exposing ( jsonString, discard )

import StringParser.Parse as Parse exposing ( Parser )


{-| Parse einen JSON-String
-}
jsonString : Parser String
jsonString =
    Parse.sequence [ discard "\"", characters, discard "\"" ]
    |> Parse.map ( String.join "" >> Array.singleton )


{-| Parse beliebig viele Zeichen
-}
characters : Parser String
characters =
    Parse.zeroOrMore character


{-| Parse ein einzelnes Zeichen
-}
character : Parser String
character =
    Parse.oneOf
        [ unescapedCharacter
        , Parse.sequence [ Parse.string "\\", escape ]
        ]


{-| Parse ein einzelnes Zeichen (unescaped)
-}
unescapedCharacter : Parser String
unescapedCharacter input =
    when String.popFirst input is
        Nothing -> Parse.fail input
        Just { first, rest } ->
            let
                c = Char.toCode first
            in
                if c < 32 || c == 34 || c == 92 || c > 1114111
                then Parse.fail input
                else Parse.string ( String.fromChar first ) input


{-| Parse ein Escape-Zeichen
-}
escape : Parser String
escape =
    Parse.oneOf
        [ Parse.oneOf <| Array.map Parse.string <| String.split "" "\"\\/bfnrt"
        , Parse.sequence [ Parse.string "u", hex, hex, hex, hex ]
        ]


{-| Parse einen hexadezimalen String
-}
hex : Parser String
hex =
    Parse.oneOf
        [ digit
        , Parse.oneOf <| Array.map Parse.string <| String.split "" "ABCDEFabcdef"
        ]


{-| Parse eine Ziffer
-}
digit : Parser String
digit =
    Parse.oneOf [ Parse.string "0", oneNine ]


{-| Parse eine positive Ziffer
-}
oneNine : Parser String
oneNine =
    Parse.oneOf <| Array.map Parse.string <| String.split "" "123456789"


{-| Parse einen String und verwirf das Ergebnis
-}
discard : String -> Parser a
discard match input =
    Parse.map ( \ _ -> [] ) ( Parse.string match ) input
